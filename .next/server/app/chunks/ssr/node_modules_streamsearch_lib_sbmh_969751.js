(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/ssr/node_modules_streamsearch_lib_sbmh_969751.js", {

"[project]/node_modules/streamsearch/lib/sbmh.js (ecmascript, ssr)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
function memcmp(buf1, pos1, buf2, pos2, num) {
    for(let i = 0; i < num; ++i){
        if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;
    }
    return true;
}
class SBMH {
    constructor(needle, cb){
        if (typeof cb !== 'function') throw new Error('Missing match callback');
        if (typeof needle === 'string') needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        this._occ = [
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen
        ];
        if (needleLen > 1) {
            for(let i = 0; i < needleLen - 1; ++i)this._occ[needle[i]] = needleLen - 1 - i;
        }
    }
    reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
    }
    push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'latin1');
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while(result !== chunkLen && this.matches < this.maxMatches)result = feed(this, chunk);
        return result;
    }
    destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
    }
}
function feed(self, data) {
    const len = data.length;
    const needle = self._needle;
    const needleLen = needle.length;
    let pos = -self._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self._occ;
    const lookbehind = self._lookbehind;
    if (pos < 0) {
        while(pos < 0 && pos <= end){
            const nextPos = pos + lastNeedleCharPos;
            const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];
            if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {
                self._lookbehindSize = 0;
                ++self.matches;
                if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);
                else self._cb(true, undefined, 0, 0, true);
                return self._bufPos = pos + needleLen;
            }
            pos += occ[ch];
        }
        while(pos < 0 && !matchNeedle(self, data, pos, len - pos))++pos;
        if (pos < 0) {
            const bytesToCutOff = self._lookbehindSize + pos;
            if (bytesToCutOff > 0) {
                self._cb(false, lookbehind, 0, bytesToCutOff, false);
            }
            self._lookbehindSize -= bytesToCutOff;
            lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);
            lookbehind.set(data, self._lookbehindSize);
            self._lookbehindSize += len;
            self._bufPos = len;
            return len;
        }
        self._cb(false, lookbehind, 0, self._lookbehindSize, false);
        self._lookbehindSize = 0;
    }
    pos += self._bufPos;
    const firstNeedleChar = needle[0];
    while(pos <= end){
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
            ++self.matches;
            if (pos > 0) self._cb(true, data, self._bufPos, pos, true);
            else self._cb(true, undefined, 0, 0, true);
            return self._bufPos = pos + needleLen;
        }
        pos += occ[ch];
    }
    while(pos < len){
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
            ++pos;
            continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self._lookbehindSize = len - pos;
        break;
    }
    if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);
    self._bufPos = len;
    return len;
}
function matchNeedle(self, data, pos, len) {
    const lb = self._lookbehind;
    const lbSize = self._lookbehindSize;
    const needle = self._needle;
    for(let i = 0; i < len; ++i, ++pos){
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i]) return false;
    }
    return true;
}
module.exports = SBMH;

}.call(this) }),
}]);

//# sourceMappingURL=node_modules_streamsearch_lib_sbmh_969751.js.map